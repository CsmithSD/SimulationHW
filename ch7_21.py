###############################################################################
# Problem: 7.21, "Fundamentals of Natural Computing"
# Author: Stephanie Athow
# Date: 18 April 2015
# Problem Statement:
#	Implement the random midpoint displacement algorithm in 3D and generate
#	some fractal landscapes. Study the influence of H on the landscapes 
#	generated.
###############################################################################

'''
2D algorithm:
	determine midpoints of current grid
	vertically perturb each new vertices generated by an appropriate gaussian 
	distribution
	repeat for each new square, decreasing perturbation at each iteration
		scaling factor should decrease by pow( 0.5, H ) at each iteration
'''

import numpy as np
import random
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

NRC = 10		# number of recursion calls
sigma = 0.3		# standard deviation of the Gaussian distribution
mu = 0			# mean of Gaussian distribution
H = 0.5			# should be 0 < H < 1

###############################################################################
#								Recursion
#	Recursively applies subdivision of the grid
###############################################################################
def Recursion( x, t0, t2, t, nrc ):
	t1 = ( t0 + t2 ) / 2 
	x[t1] = 0.5 * ( x[t0] + x[t2] ) + delta[t] * random.gauss( mu, sigma )
	if t < nrc:
		Recursion( x, t0, t1, t+1, nrc )
		Recursion( x, t1, t2, t+1, nrc )

###############################################################################
#								Plot
###############################################################################
def plotImage( x ):
	X = []
	Y = []
	Z = []
	fig = plt.figure()
	ax = fig.add_subplot( 111, projection = '3d' )
	length = len( x )
	for i in range( 0, length ):
		X.append(i)
		Y.append(0)
		Z.append( x[i] )
		#plt.scatter( i, y )
	
	#plt.plot( x )
	
	ax.plot_wireframe( X, Y, Z )
	
	#plt.grid( True )
	plt.show()
	#plt.savefig( title + '.png' )
	#plt.clf()

###############################################################################
#								Main
###############################################################################
random.seed()							# seeds the random number generator
N = pow( 2, NRC )						# number of points
x = [0]*(N+1)							# holds Brownian motion
x[N] = sigma*random.gauss( mu, sigma )	
delta = [0]* (N+1)						# holds variances 

for i in range(1, NRC):
	delta[i] = sigma * pow( 0.5, (i+1)/2 )
Recursion( x, 0, N, 1, NRC )

plotImage( x )